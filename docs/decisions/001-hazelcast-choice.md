# Решение 001: Выбор Hazelcast для кэширования

**Дата:** 2025-01-02  
**Статус:** ✅ Принято  
**Участники:** Александр  

## Проблема

Необходимо выбрать механизм кэширования для системы управления отношениями с контрагентами FEPRO для повышения производительности и снижения нагрузки на базу данных.

## Рассмотренные варианты

### 1. Redis
- **Описание:** Внешний сервер кэширования
- **Плюсы:** Высокая производительность, богатая функциональность, широкое распространение
- **Минусы:** Требует отдельный контейнер, дополнительная точка отказа, сложность развертывания

### 2. Hazelcast
- **Описание:** Встроенное решение для кэширования
- **Плюсы:** Упрощенное развертывание, встроенная персистентность, автоматическое масштабирование
- **Минусы:** Больше потребление памяти приложением, менее гибкая конфигурация

### 3. Caffeine (только локальное)
- **Описание:** Локальное кэширование в памяти JVM
- **Плюсы:** Простота, высокая производительность
- **Минусы:** Нет распределенного кэширования, данные теряются при перезапуске

## Решение

Выбран **Hazelcast** по следующим причинам:

### Основные преимущества:
1. **Упрощение развертывания** - не требуется отдельный контейнер Redis
2. **Встроенная персистентность** - данные сохраняются при обновлениях приложения
3. **Автоматическое масштабирование** - легко масштабировать кластер
4. **Меньше точек отказа** - один контейнер вместо двух
5. **Готовность к production** - встроенные механизмы надежности

### Архитектурные соображения:
- Для начальной нагрузки достаточно встроенного решения
- При росте нагрузки можно легко перейти на внешний Hazelcast кластер
- Сохранение данных критично для production обновлений

## Реализация

```yaml
# application.yml
hazelcast:
  enabled: true
  cluster:
    name: fepro-cluster
  network:
    port: 5701
    port-auto-increment: true
  management-center:
    enabled: false
```

## Последствия

### Положительные:
- ✅ Упрощенная архитектура развертывания
- ✅ Повышенная надежность (меньше компонентов)
- ✅ Встроенная персистентность данных
- ✅ Готовность к масштабированию

### Отрицательные:
- ⚠️ Больше потребление памяти приложением
- ⚠️ Менее гибкая конфигурация по сравнению с Redis

## Альтернативы на будущее

При росте нагрузки рассмотреть:
1. Внешний Hazelcast кластер
2. Миграция на Redis с кластеризацией
3. Гибридный подход (Hazelcast + Redis)

## Связанные решения

- [002-docker-architecture.md](./002-docker-architecture.md) - Архитектура развертывания
- [003-caching-strategy.md](../architecture/caching-strategy.md) - Стратегия кэширования