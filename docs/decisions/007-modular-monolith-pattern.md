# Решение 007: Modular Monolith архитектурный паттерн

**Дата:** 2025-01-02  
**Статус:** ✅ Принято  
**Участники:** Александр  

## Проблема

Необходимо выбрать архитектурный паттерн для системы управления отношениями с контрагентами FEPRO с учетом:
- Размер команды (1 разработчик)
- Сложность системы (средняя)
- Требования к масштабированию
- Простота развертывания и поддержки

## Рассмотренные варианты

### 1. Микросервисная архитектура
- **Описание:** Разделение на множество независимых сервисов
- **Плюсы:** Независимое масштабирование, технологическое разнообразие, изоляция отказов
- **Минусы:** Сложность развертывания, сетевые задержки, сложность отладки, избыточность для малой команды

### 2. Монолитная архитектура
- **Описание:** Единое приложение со всеми компонентами
- **Плюсы:** Простота развертывания, простота отладки, единая база данных
- **Минусы:** Сложность масштабирования, технологические ограничения, риск каскадных отказов

### 3. Modular Monolith
- **Описание:** Монолит с четко разделенными модулями
- **Плюсы:** Простота развертывания + модульность, возможность миграции к микросервисам
- **Минусы:** Требует дисциплины разработки, потенциальные проблемы с зависимостями

## Решение

Выбран **Modular Monolith** по следующим причинам:

### Основные преимущества:
1. **Простота для малой команды** - один разработчик может эффективно работать
2. **Простота развертывания** - единый артефакт
3. **Модульность** - четкое разделение ответственности
4. **Возможность эволюции** - легкая миграция к микросервисам
5. **Единая база данных** - упрощение транзакций

### Архитектурные принципы:

#### Модульная структура
```
fepro-backend/
├── contractor-management/     # Модуль управления отношениями с контрагентами
├── authentication/           # Модуль аутентификации
├── document-management/      # Модуль документооборота
├── gis-analytics/           # Модуль ГИС-аналитики
├── shared/                  # Общие компоненты
└── infrastructure/          # Инфраструктурные компоненты
```

#### Принципы модульности
- **Четкие границы** - каждый модуль имеет свою ответственность
- **Минимальные зависимости** - модули взаимодействуют через интерфейсы
- **Общие компоненты** - вынесены в shared модуль
- **Инфраструктура** - отдельный модуль для конфигурации

## Реализация

### Структура модулей
```java
// Модуль contractor-management
@RestController
@RequestMapping("/api/contractors")
public class ContractorController {
    
    private final ContractorService contractorService;
    
    // Только операции с контрагентами
}

// Модуль authentication  
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    private final AuthService authService;
    
    // Только операции аутентификации
}
```

### Общие компоненты
```java
// shared/common
public interface DomainEvent {
    String getEventType();
    Instant getOccurredAt();
}

// shared/infrastructure
@Component
public class EventPublisher {
    // Общая инфраструктура для событий
}
```

### Конфигурация модулей
```java
@Configuration
@EnableJpaRepositories(basePackages = "com.fepro.contractor")
@EntityScan(basePackages = "com.fepro.contractor")
public class ContractorModuleConfig {
    // Конфигурация модуля контрагентов
}
```

## Последствия

### Положительные:
- ✅ Простота разработки для малой команды
- ✅ Простота развертывания (единый JAR)
- ✅ Единая база данных и транзакции
- ✅ Простота отладки и тестирования
- ✅ Возможность эволюции к микросервисам

### Отрицательные:
- ⚠️ Требует дисциплины разработки
- ⚠️ Потенциальные проблемы с зависимостями
- ⚠️ Ограниченное независимое масштабирование
- ⚠️ Риск нарушения границ модулей

## Стратегия развития

### Phase 1: Modular Monolith
- Четкое разделение на модули
- Общие компоненты в shared
- Единая база данных

### Phase 2: Подготовка к разделению
- Введение событийной архитектуры
- Минимизация прямых зависимостей
- Подготовка API между модулями

### Phase 3: Миграция к микросервисам (при необходимости)
- Выделение наиболее нагруженных модулей
- Введение message queue
- Разделение баз данных

## Правила разработки

### 1. Границы модулей
- Модули не должны напрямую обращаться к внутренним классам других модулей
- Взаимодействие только через интерфейсы
- Общие данные через события

### 2. Зависимости
- Модули могут зависеть только от shared компонентов
- Запрещены циклические зависимости
- Использование Dependency Injection

### 3. Тестирование
- Unit тесты внутри модулей
- Integration тесты для взаимодействия модулей
- Contract тесты для API

## Мониторинг модульности

### Метрики:
- Количество зависимостей между модулями
- Размер модулей (количество классов)
- Циклические зависимости

### Инструменты:
- ArchUnit для проверки архитектурных правил
- JDepend для анализа зависимостей
- SonarQube для качества кода

## Альтернативы на будущее

При росте команды и сложности:
1. **Микросервисы** - выделение отдельных сервисов
2. **Event-driven архитектура** - асинхронное взаимодействие
3. **CQRS** - разделение команд и запросов

## Связанные решения

- [002-docker-architecture.md](./002-docker-architecture.md) - Docker архитектура
- [006-spring-boot-framework-choice.md](./006-spring-boot-framework-choice.md) - Spring Boot
- [architecture-patterns.md](../architecture/architecture-patterns.md) - Архитектурные паттерны