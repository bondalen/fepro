# Решение 002: Docker архитектура развертывания

**Дата:** 2025-01-02  
**Статус:** ✅ Принято  
**Участники:** Александр  

## Проблема

Необходимо определить архитектуру развертывания для системы FEPRO с учетом требований:
- Единый артефакт развертывания
- Минимизация размера образа
- Безопасность (non-root пользователь)
- Простота обновлений

## Рассмотренные варианты

### 1. Отдельные образы (Backend + Frontend + DB)
- **Описание:** Каждый компонент в отдельном контейнере
- **Плюсы:** Четкое разделение ответственности, независимое масштабирование
- **Минусы:** Сложность развертывания, больше контейнеров, сложнее обновления

### 2. Единый образ (Backend + Frontend)
- **Описание:** Все приложение в одном контейнере
- **Плюсы:** Простота развертывания, единый артефакт, проще обновления
- **Минусы:** Меньше гибкости масштабирования

### 3. Микросервисная архитектура
- **Описание:** Разделение на множество мелких сервисов
- **Плюсы:** Высокая масштабируемость, независимость сервисов
- **Минусы:** Избыточная сложность для текущих требований

## Решение

Выбрана **архитектура с единым образом** по следующим причинам:

### Основные преимущества:
1. **Единый артефакт развертывания** - соответствует требованиям
2. **Упрощенное развертывание** - один контейнер вместо нескольких
3. **Простота обновлений** - обновляется весь образ целиком
4. **Минимизация размера** - multi-stage build для оптимизации
5. **Безопасность** - non-root пользователь в контейнере

### Архитектурные решения:

#### Multi-stage Docker Build
```dockerfile
# Stage 1: Build Frontend
FROM node:20-alpine AS frontend-build
# ... сборка frontend

# Stage 2: Build Backend  
FROM maven:3.9-openjdk-21-alpine AS backend-build
# ... сборка backend

# Stage 3: Final Image
FROM openjdk:21-jre-alpine
# ... финальный образ
```

#### Non-root пользователь
```dockerfile
RUN addgroup -g 1001 -S fepro && \
    adduser -u 1001 -S fepro -G fepro
USER fepro
```

#### Отдельный контейнер PostgreSQL
- База данных в отдельном контейнере для персистентности
- Использование Docker volumes для данных
- Health checks для мониторинга

## Реализация

### Docker Compose структура:
```yaml
services:
  fepro-app:
    build: .
    ports: ["8082:8082"]
    depends_on: [postgres]
    user: "fepro:1001"
    
  postgres:
    image: postgres:16-alpine
    volumes: ["postgres_data:/var/lib/postgresql/data"]
```

### Скрипты развертывания:
- `deploy.sh` - полное развертывание
- `update.sh` - обновление с сохранением данных
- `backup.sh` - резервное копирование
- `blue-green-deploy.sh` - безпростое обновление

## Последствия

### Положительные:
- ✅ Единый артефакт развертывания
- ✅ Упрощенное управление обновлениями
- ✅ Минимизированный размер образа (~200-300MB)
- ✅ Безопасность (non-root пользователь)
- ✅ Автоматические бэкапы и откаты

### Отрицательные:
- ⚠️ Меньше гибкости масштабирования отдельных компонентов
- ⚠️ Обновление всего приложения при изменениях в одной части

## Стратегия обновлений

### Rolling Update
1. Создание бэкапа базы данных
2. Сборка нового образа
3. Обновление контейнера приложения
4. Проверка здоровья
5. Откат при неудаче

### Blue-Green Deployment
1. Развертывание новой версии параллельно
2. Тестирование новой версии
3. Переключение трафика
4. Остановка старой версии

## Мониторинг

- Health checks для всех сервисов
- Prometheus метрики
- Логирование с ротацией
- Автоматические бэкапы

## Связанные решения

- [001-hazelcast-choice.md](./001-hazelcast-choice.md) - Выбор кэширования
- [deployment-strategy.md](../architecture/deployment-strategy.md) - Стратегия развертывания